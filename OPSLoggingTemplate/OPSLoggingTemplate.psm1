<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2016 v5.2.128
     Generated on:       9/14/2016 4:56 PM
     Generated by:       Robert O'Dell
     Organization:       One Technologies
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2016
#>

Function Get-OTConfig{
    <#
    .SYNOPSIS
        Ingests the configuration file
    .DESCRIPTION
        This function will ingest the JSON configuration file. This should be the only location where the file path is hard-coded. The 
        fucntion will perform the folllowing tasks:
            1) Get the contents of the file and convert it from JSON document
            2) Return the contents
    .EXAMPLE
        $Config = Get-OTConfig
    #>
    [CmdletBinding()]
    param(
    )
    BEGIN{
    }
    PROCESS{
        #Convert config file from JSON
        $config = Get-Content "::CONFIGFILE::" | ConvertFrom-Json
    }
    END{
        #Return it
        return $config
    }
}

Function Add-ToLog{
    <#
    .SYNOPSIS
        Adds log message to the log file provided with an option to pass through to the console
    .DESCRIPTION
        This function will format the given message and error information into a uniform log style. This function
        will execute the following steps:
            1) Detect if a error message is given and format
            2) Append formatted message to log supplied
            3) Pass message to console if required
    .PARAMETER Path
        UNC path to .log file. This file should be pulled from config within the calling module
    .PARAMETER Message
        String that will be published to the log
    .PARAMETER Type
        The type header the log line should be represented as
    .PARAMETER ErrorMessage
        String provided from PowerShell Error Exception. This should be attained by catching "$_.Exception.Message" within the calling script
    .PARAMETER Console
        Switch used for passing log context through to Write-ToConsole function
    .EXAMPLE
        Add-ToLog $Log "Message to pass" -Type ERR -ErrorMessage $_.Exception.Message -Console
    .EXAMPLE
        Add-ToLog $Log "Message to pass" -Type INF
    #>
    [CmdletBinding()]
    Param(
 	    [Parameter(Mandatory=$True,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [String] $Message,
        [ValidateSet("INF","WRN","ERR","HDR","CON","DIS","RES")]
        [String] $Type,
        [Parameter(Mandatory=$False,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
 	    [String] $Path,
        [String] $ErrorMessage,
        [Switch] $Console
    )
    Begin{
        #Get logging path
        if(!$Path){$Path = Get-LogPath}
        Resolve-LogFile $Path
    }
    Process{
        #Format for error message
        if($ErrorMessage){
            $Message += ". The error returned was [$ErrorMessage]" -replace "`n|`r|`t",""
        }

        #Write to log
        Add-Content $Path "$Type | $(get-date -Format "MM/dd/yy HH:mm:ss") | $Message"
        
        #Print to console
        if($Console){
            Write-ToConsole -Message $Message -Type $Type
        }
    }
    End{
        
    }
}

Function Write-ToConsole{
    <#
    .SYNOPSIS
        Formats and writes the contents of a message and error to the console
    .DESCRIPTION
        This function format and print the given message and error into the console using write-host. I'm aware of the problems with
        Write-Host, but there are some wonky issues with streams that I've yet to iron out The function will perform the following
        tasks:
            1) Determine Write-Host color based on type
            2) Detect error message and format message
            3) Print to console
    .PARAMETER Message
        String that will be published to the console
    .PARAMETER Type
        The type header the log line should be represented as
    .PARAMETER ErrorMessage
        String provided from PowerShell Error Exception. This should be attained by catching "$_.Exception.Message" within the calling script
    .EXAMPLE
        Write-ToConsole "Message to be written" -Type ERR -ErrorMessage $_.Exception.Message
    .EXAMPLE
        Write-ToConsole "Message to be written" -Type INF
    #>
    [CmdletBinding()]
    Param(
 	    [Parameter(Mandatory=$True,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [String] $Message,
        [ValidateSet("INF","WRN","ERR","HDR","CON","DIS","RES")]
        [String] $Type,
        [Parameter(Mandatory=$False,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [String] $ErrorMessage
    )
 
    Begin{
        #Color picker
        $Flag = "-ForegroundColor"
        Switch($Type){
            "INF" {$Color = "White"}
            "WRN" {$Color = "Yellow"}
            "ERR" {$Color = "Red"}
            "HDR" {$Color = "White"}
            "CON" {$Color = "Green"}
            "DIS" {$Color = "DarkYellow"}
            "RES" {$Color = "White"}
        }
        $Suffix = $Flag + " $Color"
    }
    Process{
        #Detect error message
        if($ErrorMessage){
            $Message += ". The error returned was [$ErrorMessage]" -replace "`n|`r|`t",""
        }

        #Print to console
        Invoke-Expression "Write-Host `"$Type | $(get-date -Format "MM/dd/yy HH:mm:ss") | $Message`" $Suffix"
    }
    End{
        
    }
}

Function New-LogEntry{
    <#
    .SYNOPSIS
        Initiates a new log entry, creating a new file if necessary
    .DESCRIPTION
        This function will generate a new log file if the supplied log does not exist and insert a uniform header. The fucntion will
        perform the folllowing tasks:
            1) Detects job type
            2) Detects existing log file and creates a log if one isn't detected
            3) Formats and adds log line of type HDR with computer, time, and user
            4) Writes line to console if needed
    .PARAMETER Path
        UNC path to .log file. This file should be pulled from config within the calling module
    .PARAMETER Comment
        Custom comment for the log line
    .PARAMETER JobType
        Optional parameter for populating the type of job that is running
    .PARAMETER Console
        Switch used for passing log context through to Write-ToConsole function
    .EXAMPLE
        New-LogEntry $Log -Comment "Optional comment" -JobType "Logging Test" -Console
    .EXAMPLE
        New-LogEntry $Log -JobType "Logging Test"
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [String] $Comment,
        [String] $Path,
        [String] $JobType,
        [Switch] $Console
    )
    Begin{
        #Get logging path
        if(!$Path){$Path = Get-LogPath}

        #Detect job type
        $WarningPreference='silentlycontinue'
        if($JobType){$JobString = "$JobType job"}else{$JobString = "Job"}

        #Detect comment
        if($Comment){$CommentString = "with user comment [$Comment]"} else {$CommentString = "without comments"}
        
        #Send path to resolver
        Resolve-LogFile $Path
    }
    Process{
        #Add header to log file for current job
        Add-ToLog "$JobString started from $($env:COMPUTERNAME) by $($env:USERNAME) $CommentString" -Type HDR
        
        #Send to console if required
        if($Console){
            Write-ToConsole "$JobString started" -Type INF
        }
    }
    End{
        
    }
}

Function Close-LogEntry{
    <#
    .SYNOPSIS
        Closes a log entry with result data and optionally sends an email
    .DESCRIPTION
        This function will close out a log entry with a reolution state and optionally initiate an email. The fucntion will
        perform the folllowing tasks:
            1) Writes resolution to log file
            2) Writes resolution to console if selected
            3) Sends email with default settings
    .PARAMETER Path
        UNC path to .log file. This file should be pulled from config within the calling module
    .PARAMETER Result
        A list of predetermined log result status
    .PARAMETER SendEmail
        Passes data to the email function, sending emails to the default setup
    .PARAMETER Console
        Switch used for passing log context through to Write-ToConsole function
    .EXAMPLE
        New-LogEntry $Log -Comment "Optional comment" -JobType "Logging Test" -Console
    .EXAMPLE
        New-LogEntry $Log -JobType "Logging Test"
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [ValidateSet("Success","Failure","Seccess with exceptions")]
        [String] $Result,
        [Parameter(Mandatory=$False,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
    	[String] $Path,
        [Switch] $SendEmail,
        [Switch] $Console

    )
    Begin{
        #Get logging path
        if(!$Path){$Path = Get-LogPath}
    }
    Process{
        #Write to log
        Add-ToLog "Job ended with a status of $Result" -Type RES

        #Writes data to console
        if($Console){
            Write-ToConsole "Job ended with a status of $Result" -Type RES
        }
        
        #Detect and send email
        if($SendEmail){
            Send-LogEmail $Result
        }
    }
    End{
        
    }
}

Function Send-LogEmail{
    <#
    .SYNOPSIS
        Sends the closing log email with the given parameters
    .DESCRIPTION
        This function will send out the closing log email to the given parameters. It will ingest parameters from configuration
        file if no arguments are supplied. The fucntion will perform the folllowing tasks:
            1) Grabs default config file
            2) Determines if defaults should be used
            3) Builds the mail message
            4) Sends email message
    .PARAMETER Result
        A predetermined status that matches the Close-LogEntry function
    .PARAMETER Path
        The UNC path to the log file where details about the job the email will be referencing. This will be included in the email
    .PARAMETER To
        The email address of the primary recipient
    .PARAMETER Cc
        The email address of the carbon copy recipient
    .PARAMETER SMTP
        The address of the SMTP server
    .EXAMPLE
        Send-LogEmail -Result "Success"
    .EXAMPLE
        Send-LogEmail -Result "Success with exceptions" -To "address@domain.com"
    #>
    [CmdletBinding()]
    Param(
 	    [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelineByPropertyName=$True)]
        [ValidateSet("Success","Failure","Success with exceptions")]
        [String] $Result,
        [Parameter(Mandatory=$False,ValueFromPipeline=$False,ValueFromPipelineByPropertyName=$False)]
        [ValidatePattern("[a-z]\w+(?=\.log)")]
        [String] $Path,
        [String] $To,
        [String] $Cc,
        [String] $SMTP
    )
 
    Begin{
        #Get logging path
        if(!$Path){$Path = Get-LogPath}

        #Get name of the log for use
        $Config = Get-OTConfig

        #Overwrite default messaging variables as detected
        if(!$To){$EmailTo = $config.Globals.Email.EmailTo}else{$EmailTo = $To}
        if(!$Cc){$EmailCc = $config.Globals.Email.EmailCc}else{$EmailCc = $Cc}
        if(!$SMTP){$SMTPServer = $config.Globals.Email.SMTP}else{$SMTPServer = $SMTP}

        #From account
        $EmailFrom = $config.Globals.Email.SendAs
    }
    Process{
        #Build email data
        $EmailSubject = "AUTOMATION | $LogName reports $Result on $(get-date -f g)"

        switch($Result){
            "Success" {$EmailHead="The $LogName job was run Successfully from $($env:COMPUTERNAME) at $(get-date -f g).`n`n"}
            "Failure" {$EmailHead="The $LogName job from $($env:COMPUTERNAME) failed at $(get-date -f g).`n`n"}
            "Success with exceptions" {$EmailHead="The $LogName job from $($env:COMPUTERNAME) was successful, but encountered errors at $(get-date -f g).`n`n"}
        }

        $EmailFoot ="Please refer to the job log ($Path) for further details.`n`nRegards,`n`nOps"
        $EmailBody = $EmailHead + $EmailFoot

        #Send Email Log
        Send-MailMessage -To $EmailTo -Cc $EmailCc -From $EmailFrom -Subject $EmailSubject -SmtpServer $SMTPServer -body $EmailBody
    }
    End{
        
    }
}

Function Get-LogEntry{
    <#
    .SYNOPSIS
        Parses the selected log and identifies rows that match the criteria
    .DESCRIPTION
        This function will supply a list of log files located in the default log root and return a contextual list of the logs it's able to
        process. It will then attempt to parse the strings that match the criteria. The fucntion will perform the folllowing tasks:
            1) Search the default log root and return a list of plausible files to search
            2) Get the full path of the selected file
            3) Search for Contains variable data
            4) Search for Type variable data
            5) Search for Exlude variable data
            6) Return the result set
    .PARAMETER Contains
        Regex expression or plain string search parameter
    .PARAMETER Type
        Predefined validate set that matches the Add-ToLog selections
    .PARAMETER Exclude
        Regex expression or plain string search parameter
    .EXAMPLE
        Get-LogEntry -LogFile FileNameWithoutExtension -Contains "Search String" -Type ERR -Exclude "Exclude String"
    .EXAMPLE
        Get-LogEntry -LogFile FileNameWithoutExtension -Type ERR -Exclude "Exclude String"
    #>
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory=$False,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [String]$Contains,
        [ValidateSet("INF","WRN","ERR","HDR","CON","DIS","RES")]
        [String]$Type,
        [String]$Exclude
    )

    DynamicParam{
        #Name the parameter and get the config
        $ParameterName = 'LogFile'
        $Config = Get-OTConfig

        #Initiate dictionary and assign attributes
        $Dictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
        $AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
        $ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
        $ParameterAttribute.Mandatory = $true
        $ParameterAttribute.Position = 1
        $AttributeCollection.Add($ParameterAttribute)

        #Query the default log location and generate a list of file names that have log content
        $arrSet = Get-ChildItem -Path $Config.Globals.LogRoot -Recurse -File | ? {$_.Name -match "[a-z]\w+(?=\.log)"} | Select -ExpandProperty BaseName
        $ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
        $AttributeCollection.Add($ValidateSetAttribute)

        #Place query data into the dictionary and return it as a context menu
        $RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ParameterName, [string], $AttributeCollection)
        $Dictionary.Add($ParameterName, $RuntimeParameter)
        return $Dictionary
    }
    Begin{
        #Get config and get the UNC path of the log selected previously
        $Config = Get-OTConfig
        $FileName = $PsBoundParameters[$ParameterName]
        $FilePath = Get-ChildItem -Path $Config.Globals.LogRoot -Recurse -File | ? {$_.Name -match $FileName} | Select -ExpandProperty FullName
    }
    Process{
        #Grab the contents of the selected file. This can no doubt be written more efficiently but I have other shit to do
        $LogData = Get-Content -Path $FilePath

        #Filter down to rows that match Contains data
        if($Contains){
            $LogData = $LogData | Select-String $Contains
        }

        #Filter down to rows that match Type data. Type data is second due to there potentially being more rows of type matches
        if($Type){
            $LogData = $LogData | Select-String "$Type \| "
        }

        #Filter down to rows that match Exclude data
        if($Exclude){
            $LogData = $LogData | Select-String -NotMatch $Exclude
        }      
    }
    End{
        #Dump rows to console. Eventually I will move these into a proper object to enable more advanced searches, but for now they will live as string rows
        $LogData  
    }
}

Function Resolve-LogFile{
    <#
    .SYNOPSIS
        Resolves the log path based on the configuration file supplied
    .DESCRIPTION
        This function will automatically create the log file given the supplied path if it doesn not already exist. 
        The fucntion will perform the folllowing tasks:
            1) Check if the folder exists, creating it if required
            2) Check if the file exists, creating it if required
    .PARAMETER Path
        The UNC path that the function will be checking for
    .EXAMPLE
        Resolve-LogFile $Path
    #>
    [CmdletBinding()]
    Param(
 	    [Parameter(Mandatory=$True,ValueFromPipeline=$False,ValueFromPipelineByPropertyName = $False)]
        [ValidatePattern("[a-z]\w+(?=\.log)")]
 	    [String]$Path=""
    )
    Begin{
        $Folder = Split-Path $Path
        $File = Split-Path $Path -Leaf
    }
    Process{
        #Check if file exists, create file if it doesn't
        if(!(Test-Path $Path -PathType Leaf)){
            if(!(Test-Path -Path $Folder -PathType Container)){
                Write-ToConsole "Folder not detected, creating new folder [$Folder]" -Type WRN
                New-Item -Path $Folder -ItemType Directory | Out-Null
            }
            Write-ToConsole "File not detected, creating new file [$File]" -Type WRN
            New-Item $Folder -Name $File -ItemType File | Out-Null
        }
    }
    End{
        
    }
}

Function Get-LogPath{
    <#
    .SYNOPSIS
        Automatically determines the log that should be used for the calling function
    .DESCRIPTION
        This function will look at which module, script, or function is calling for a log write and determine which file and folder it should be writing to based
        off of the configuration file. The fucntion will perform the folllowing tasks:
            1) Get the Call Stack
            2) Parse the Call Stack to determine if it is being called by a script or module
            3) Search for a configuration for the specific function of the module, if one is not defined it will direct the log message to defaults
            4) Search for a configuration for the script, if one is not defined it will direct the log message to defaults
            5) Determine log UNC path and return it
    .EXAMPLE
        $Path = Get-LogPath
    .NOTES
        The automatic resolution assumes the last calling module is the owner of the log message. The function will ignore calls made within the logging module, but it
        may encounter strange behavior with nested modules. For best results each function should be logging its own messages. Do not pass log messages down the pipe.
    #>
    [CmdletBinding()]
    param(
    )
    BEGIN{
        #Get Config file and CallStack for processing
        $config = Get-OTConfig
        $Stack = Get-PSCallStack
    }
    PROCESS{
        #Determine position in callstack, ignoring calls from within this module
        $Self = $MyInvocation.PSScriptRoot.Split("\")[-1]
        $ModuleMatch = $Stack | ?{($_.Location -notmatch $Self) -and ($_.Location -notmatch "<No file>") -and ($_.Location -match ".psm1")}
        $ScriptMatch = $Stack | ?{($_.Location -notmatch $Self) -and ($_.Location -notmatch "<No file>") -and ($_.Location -match ".ps1")}
        
        #Check for Module matches first since it's designed specifically for modules
        if($ModuleMatch){
            #Populate the name of the calling function and the module it lives in
            $Module = $ModuleMatch[0].Location.Split(".")[0]
            $Function = $ModuleMatch[0].Command.Split(".")[0]

            #Search config for specific log path requirements
            $LogData = $config.Modules | ? Name -match $Module | Select -Expand Functions | ? Name -Match $Function | Select -Expand Log
            
            #Format appropriately, selecting defaults if needed
            if($LogData){
                $LogFile = $config.Globals.LogRoot + $LogData
            } else {
                $LogFile = $config.Globals.LogRoot + $config.Globals.ModuleLogRoot + "$Function.Log"
            }

        #Check if the calling function is actually part of a script
        } elseif($ScriptMatch) {
            #Assign the script and function name. These may be the same name
            $Script = $ScriptMatch[0].Location.Split(".")[0]
            $Name = $ScriptMatch[0].Command.Split(".")[0]

            #Search the config file for matching script log data. If not exist, select the default
            $LogData = $config.Scripts | ? Name -Match $Script | Select -Expand Log
            if($LogData){
                $LogFile = $config.Globals.LogRoot + $config.Globals.ScriptLogRoot + $LogData
            } else {
                $LogFile = $config.Globals.LogRoot + $config.Globals.ScriptLogRoot + "$Name.log"
            }
        }
    }
    END{
        #Return the UNC log path
        Return $LogFile
    }
}

	Export-ModuleMember -Function Get-OTConfig,
                        Add-ToLog,
                        Write-ToConsole,
                        New-LogEntry,
                        Close-LogEntry,
                        Send-LogEmail,
                        Get-LogEntry,
                        Resolve-LogFile,
                        Get-LogPath